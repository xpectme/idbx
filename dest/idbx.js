var I="onsuccess",D="onerror";function a(r){return new Promise((e,t)=>{r[I]=n=>{let i=n.target;e(i.result)},r[D]=()=>{t(r.error)}})}function m(r,e,t,n){let i=!1,u,s,d=new Promise((l,o)=>{u=l,s=o});return t&&d.then(t).catch(n),r[I]=async l=>{let o=l.target?.result;o&&!i?(i=await e?.(o)??!1,i===!0&&u()):i||(i=!0,u())},r[D]=()=>{s(r.error)},d}function g(r,e,t){return Array.isArray(e)?Promise.all(e.map(n=>a(r.add(n,t)))):a(r.add(e,t))}function S(r){return a(r.clear())}function h(r,e){return a(r.count(e))}function P(r,e){return Array.isArray(e)?Promise.all(e.map(t=>a(r.delete(t)))):a(r.delete(e))}function j(r,e){return a(r.get(e))}function E(r,e,t){return a(r.getAll(e,t))}function W(r,e,t){return a(r.getAllKeys(e,t))}function f(r,e,t="readonly"){return r.transaction([e],t).objectStore(e)}function M(r,e,t){return f(r,e,"readonly").index(t)}function G(r,e){return a(r.getKey(e))}function Q(r,e,t){let n,i,u,s=()=>(n=new Promise((o,c)=>{i=o,u=c}),n),d=o=>{let c=o.value;i(c),s&&n.then(s),o.continue()},l=r.openCursor(e,t);return m(l,d).then(()=>s=void 0).catch(o=>u(o)),{async*[Symbol.asyncIterator](){try{for(;s;)yield await s()}catch(o){throw o}}}}function $(r,e,t){let n,i,u,s=()=>(n=new Promise((o,c)=>{i=o,u=c}),n),d=o=>{let c=o.key;i(c),s&&n.then(s),o.continue()},l=r.openKeyCursor(e,t);return m(l,d).then(()=>s=void 0).catch(o=>u(o)),{async*[Symbol.asyncIterator](){try{for(;s;)yield await s()}catch(o){throw o}}}}function te(r,e={}){let t=indexedDB.open(r,e.version);return t.onupgradeneeded=n=>{if(e.upgrade){let i=n.target.result;e.upgrade(i,n)}},e.blocked&&(t.onblocked=e.blocked),new Promise((n,i)=>{t[I]=()=>n(t.result),t[D]=()=>i(t.error)})}function ae(r,e,t){return Array.isArray(e)?Promise.all(e.map(n=>a(r.put(n,t)))):a(r.put(e,t))}export{g as add,a as asyncRequest,S as clear,h as count,m as cursorHandler,P as del,j as get,E as getAll,W as getAllKeys,M as getIndex,G as getKey,f as getStore,Q as iterate,$ as iterateKeys,te as openDB,ae as put};
//# sourceMappingURL=idbx.js.map
