function a(r){return new Promise((e,t)=>{r.addEventListener("success",o=>{let n=o.target;e(n.result)}),r.addEventListener("error",o=>{let n=o.target;t(new Error(`IndexedDB error: ${n.error?.message}`))})})}function D(r,e,t){let o=r.openCursor(),n=!1;o.onsuccess=d=>{let s=d.target?.result;s&&!n?(n=e?.(s)??!1,n&&t?.()):n||(n=!0,t?.())},o.onerror=()=>{throw o.error}}function y(r,e,t){return Array.isArray(e)?Promise.all(e.map(o=>a(r.add(o,t)))):a(r.add(e,t))}function x(r,e=[]){return Promise.all(e.map(t=>y(r,t)))}function u(r,e,t){let o=t.length;t.push([e,void 0]),r.onsuccess=n=>{let d=n.target.result;t[o]=[e,d===void 0?!0:d]},r.onerror=()=>{t[o]=[e,!1]}}function R(r,e,t){let o=new Set(e.map(l=>l.storeName)),n=Array.from(o),d=r.transaction(n,t),s=[];for(let l of e){let i=d.objectStore(l.storeName);switch(l.method){case"add":{let{data:c,key:m}=l;if(Array.isArray(c))for(let B of c)u(i.add(B,m),"add",s);else u(i.add(c,m),"add",s);break}case"put":{let{data:c,key:m}=l;if(Array.isArray(c))for(let B of c)u(i.put(B,m),"put",s);else u(i.put(c,m),"put",s);break}case"del":{if("keys"in l)for(let c of l.keys)u(i.delete(c),"del",s);else"key"in l&&u(i.delete(l.key),"del",s);break}case"clear":{u(i.clear(),"clear",s);break}case"get":{let{query:c}=l;u(i.get(c),"get",s);break}case"getAll":{let{query:c,count:m}=l;u(i.getAll(c,m),"getAll",s);break}case"getAllKeys":{let{query:c,count:m}=l;u(i.getAllKeys(c,m),"getAllKeys",s);break}case"getKey":{let{query:c}=l;u(i.getKey(c),"getKey",s);break}case"count":{let{query:c}=l;u(i.count(c),"count",s);break}}}return{abort:()=>d.abort(),completed:new Promise((l,i)=>{d.oncomplete=()=>l(s),d.onerror=()=>i(d.error)})}}function A(r){return a(r.clear())}function V(r,e){return a(r.count(e))}function I(r,e){return Array.isArray(e)?Promise.all(e.map(t=>a(r.delete(t)))):a(r.delete(e))}function j(r,e){return Promise.all(e.map(t=>I(r,t)))}function E(r,e){return a(r.get(e))}function H(r,e,t){return a(r.getAll(e,t))}function W(r,e,t){return a(r.getAllKeys(e,t))}function F(r,e){return a(r.getKey(e))}function Q(r,e,t="readonly"){return r.transaction([e],t).objectStore(e)}function Z(r){let e,t,o,n=()=>(e=new Promise((d,s)=>{t=d,o=s}),e);return D(r,d=>{let s=d.value;t(s),n&&e.then(n),d.continue()},()=>n=void 0),{async*[Symbol.asyncIterator](){for(;n;)try{yield await n()}catch(d){throw d}}}}function te(r,e){let t=indexedDB.open(r,e);return{upgrade:o=>{t.onupgradeneeded=o},blocked:o=>{t.onblocked=o},ready:new Promise((o,n)=>{t.onsuccess=()=>o(t.result),t.onerror=()=>n(t.error)})}}function oe(r,e={}){let t=indexedDB.open(r,e.version);return t.onupgradeneeded=o=>{if(e.upgrade){let n=o.target.result;e.upgrade(n,o)}},e.blocked&&(t.onblocked=e.blocked),new Promise((o,n)=>{t.onsuccess=()=>o(t.result),t.onerror=()=>n(t.error)})}function f(r,e,t){return Array.isArray(e)?Promise.all(e.map(o=>a(r.put(o,t)))):a(r.put(e,t))}function de(r,e=[]){return Promise.all(e.map(t=>f(r,t)))}export{y as add,x as addBulk,a as asyncRequest,R as batch,A as clear,V as count,D as cursorHandler,I as del,j as delBulk,E as get,H as getAll,W as getAllKeys,F as getKey,Q as getStore,Z as iterate,te as open,oe as openDB,f as put,de as putBulk};
//# sourceMappingURL=idbx.js.map
