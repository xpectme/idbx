{
  "version": 3,
  "sources": ["../core/eventTypes.ts", "../core/asyncRequest.ts", "../core/cursorHandler.ts", "../ops/add.ts", "../ops/clear.ts", "../ops/count.ts", "../ops/del.ts", "../ops/get.ts", "../ops/getAll.ts", "../ops/getAllKeys.ts", "../ops/getStore.ts", "../ops/getIndex.ts", "../ops/getKey.ts", "../ops/iterate.ts", "../ops/iterateKeys.ts", "../ops/openDB.ts", "../ops/put.ts"],
  "sourcesContent": ["export const ON_SUCCESS = \"onsuccess\";\nexport const ON_ERROR = \"onerror\";\n", "import { ON_ERROR, ON_SUCCESS } from \"./eventTypes.ts\";\nexport function asyncRequest<T>(\n  req: IDBRequest<T>,\n) {\n  return new Promise<T>((resolve, reject) => {\n    req[ON_SUCCESS] = (ev) => {\n      const target = ev.target as IDBRequest;\n      resolve(target.result);\n    };\n    req[ON_ERROR] = () => {\n      reject(req.error);\n    };\n  });\n}\n", "import { ON_ERROR, ON_SUCCESS } from \"./eventTypes.ts\";\nexport function cursorHandler(\n  request: IDBRequest<IDBCursorWithValue | null> |\u00A0IDBRequest<IDBCursor | null>,\n  iterator: (\n    cursor: IDBCursorWithValue,\n  ) => boolean | void | Promise<boolean | void>,\n  onEnd?: () => void,\n  onError?: (reason?: unknown) => void,\n): Promise<void> {\n  let ended = false;\n\n  let _resolve: () => void | Promise<void>;\n  let _reject: (reason?: unknown) => void | Promise<void>;\n\n  const _promise = new Promise<void>((resolve, reject) => {\n    _resolve = resolve;\n    _reject = reject;\n  });\n\n  if (onEnd) {\n    _promise.then(onEnd).catch(onError);\n  }\n\n  // deno-lint-ignore no-explicit-any\n  request[ON_SUCCESS] = async (event: any) => {\n    const cursor = event.target?.result as IDBCursorWithValue;\n    if (cursor && !ended) {\n      ended = await iterator?.(cursor) ?? false;\n      if (ended === true) {\n        _resolve();\n      }\n    } else if (!ended) {\n      ended = true;\n      _resolve();\n    }\n  };\n\n  request[ON_ERROR] = () => {\n    _reject(request.error);\n  };\n\n  return _promise;\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function add<T>(\n  store: IDBObjectStore,\n  item: T | T[],\n  key?: IDBValidKey,\n): Promise<IDBValidKey> {\n  if (Array.isArray(item)) {\n    return Promise.all(item.map((i) => asyncRequest(store.add(i, key))));\n  }\n  return asyncRequest(store.add(item, key));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function clear(store: IDBObjectStore) {\n  return asyncRequest(store.clear());\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function count(\n  store: IDBObjectStore | IDBIndex,\n  query?: IDBValidKey | IDBKeyRange,\n) {\n  return asyncRequest(store.count(query));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function del(\n  store: IDBObjectStore,\n  query: IDBValidKey | IDBKeyRange,\n) {\n  if (Array.isArray(query)) {\n    return Promise.all(query.map((q) => asyncRequest(store.delete(q))));\n  }\n  return asyncRequest(store.delete(query));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function get<T>(\n  store: IDBObjectStore | IDBIndex,\n  query: IDBValidKey | IDBKeyRange,\n) {\n  // indexeddb get operation\n  return asyncRequest<T | undefined>(store.get(query));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function getAll<T>(\n  store: IDBObjectStore | IDBIndex,\n  query?: IDBValidKey | IDBKeyRange,\n  count?: number,\n) {\n  // indexeddb get operation\n  return asyncRequest<T[]>(store.getAll(query, count));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function getAllKeys(\n  store: IDBObjectStore | IDBIndex,\n  query?: IDBValidKey | IDBKeyRange,\n  count?: number,\n) {\n  // indexeddb get operation\n  return asyncRequest<IDBValidKey[]>(store.getAllKeys(query, count));\n}\n", "export function getStore(\n  db: IDBDatabase,\n  storeName: string,\n  mode: IDBTransactionMode = \"readonly\",\n) {\n  const transaction = db.transaction([storeName], mode);\n  const store = transaction.objectStore(storeName);\n  return store;\n}\n", "import { getStore } from \"./getStore.ts\";\n\nexport function getIndex(\n  db: IDBDatabase,\n  storeName: string,\n  indexName: string,\n) {\n  return getStore(db, storeName, \"readonly\").index(indexName);\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function getKey(\n  store: IDBObjectStore | IDBIndex,\n  query: IDBValidKey | IDBKeyRange,\n) {\n  // indexeddb get operation\n  return asyncRequest<IDBValidKey | undefined>(store.getKey(query));\n}\n", "import { cursorHandler } from \"../core/cursorHandler.ts\";\n\nexport function iterate<T>(\n  store: IDBObjectStore | IDBIndex,\n  query?: IDBValidKey | IDBKeyRange | null,\n  direction?: IDBCursorDirection,\n): AsyncIterable<T> {\n  let _promise: Promise<T>;\n  let _resolve: (value: T) => void;\n  let _reject: (reason?: unknown) => void;\n\n  let next: (() => Promise<T>) | void = () => {\n    _promise = new Promise<T>((resolve, reject) => {\n      _resolve = resolve;\n      _reject = reject;\n    });\n    return _promise;\n  };\n\n  const iterator = (cursor: IDBCursorWithValue) => {\n    const value = cursor.value as T;\n    _resolve(value);\n    if (next) {\n      _promise.then(next);\n    }\n    cursor.continue();\n  };\n\n  const request = store.openCursor(query, direction);\n  cursorHandler(request, iterator)\n    .then(() => (next = undefined))\n    .catch((reason) => _reject(reason));\n\n  return {\n    async *[Symbol.asyncIterator]() {\n      try {\n        while (true) {\n          if (next) {\n            const result = await next();\n            yield result;\n          } else {\n            break;\n          }\n        }\n      } catch (error) {\n        throw error;\n      }\n    },\n  };\n}\n", "import { cursorHandler } from \"../core/cursorHandler.ts\";\n\nexport function iterateKeys(\n  store: IDBObjectStore | IDBIndex,\n  query?: IDBValidKey | IDBKeyRange | null,\n  direction?: IDBCursorDirection,\n): AsyncIterable<IDBValidKey> {\n  let _promise: Promise<IDBValidKey>;\n  let _resolve: (value: IDBValidKey) => void;\n  let _reject: (reason?: unknown) => void;\n\n  let next: (() => Promise<IDBValidKey>) | void = () => {\n    _promise = new Promise<IDBValidKey>((resolve, reject) => {\n      _resolve = resolve;\n      _reject = reject;\n    });\n    return _promise;\n  };\n\n  const iterator = (cursor: IDBCursorWithValue) => {\n    const value = cursor.key;\n    _resolve(value);\n    if (next) {\n      _promise.then(next);\n    }\n    cursor.continue();\n  };\n\n  const request = store.openKeyCursor(query, direction);\n  cursorHandler(request, iterator)\n    .then(() => (next = undefined))\n    .catch((reason) => _reject(reason));\n\n  return {\n    async *[Symbol.asyncIterator]() {\n      try {\n        while (true) {\n          if (next) {\n            const result = await next();\n            yield result;\n          } else {\n            break;\n          }\n        }\n      } catch (error) {\n        throw error;\n      }\n    },\n  };\n}\n", "import { ON_ERROR, ON_SUCCESS } from \"../core/eventTypes.ts\";\ninterface IDBXOpenOptions {\n  version?: number;\n  upgrade?: (db: IDBDatabase, event: IDBVersionChangeEvent) => void;\n  blocked?: (event: Event) => void;\n}\n\nexport function openDB(name: string, options: IDBXOpenOptions = {}) {\n  const request = indexedDB.open(name, options.version);\n\n  request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n    if (options.upgrade) {\n      // deno-lint-ignore no-explicit-any\n      const db = (event.target as any).result;\n      options.upgrade(db, event);\n    }\n  };\n\n  if (options.blocked) {\n    request.onblocked = options.blocked;\n  }\n\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    request[ON_SUCCESS] = () => resolve(request.result);\n    request[ON_ERROR] = () => reject(request.error);\n  });\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function put<T>(store: IDBObjectStore, item: T | T[], key?: IDBValidKey) {\n  if (Array.isArray(item)) {\n    return Promise.all(item.map((i) => asyncRequest(store.put(i, key))));\n  }\n  return asyncRequest(store.put(item, key));\n}\n"],
  "mappings": "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",
  "names": ["ON_SUCCESS", "ON_ERROR", "asyncRequest", "req", "resolve", "reject", "ON_SUCCESS", "ev", "target", "ON_ERROR", "cursorHandler", "request", "iterator", "onEnd", "onError", "ended", "_resolve", "_reject", "_promise", "resolve", "reject", "ON_SUCCESS", "event", "cursor", "ON_ERROR", "add", "store", "item", "key", "i", "asyncRequest", "clear", "store", "asyncRequest", "count", "store", "query", "asyncRequest", "del", "store", "query", "q", "asyncRequest", "get", "store", "query", "asyncRequest", "getAll", "store", "query", "count", "asyncRequest", "getAllKeys", "store", "query", "count", "asyncRequest", "getStore", "db", "storeName", "mode", "getIndex", "db", "storeName", "indexName", "getStore", "getKey", "store", "query", "asyncRequest", "iterate", "store", "query", "direction", "_promise", "_resolve", "_reject", "next", "resolve", "reject", "iterator", "cursor", "value", "request", "cursorHandler", "reason", "error", "iterateKeys", "store", "query", "direction", "_promise", "_resolve", "_reject", "next", "resolve", "reject", "iterator", "cursor", "value", "request", "cursorHandler", "reason", "error", "openDB", "name", "options", "request", "event", "db", "resolve", "reject", "ON_SUCCESS", "ON_ERROR", "put", "store", "item", "key", "i", "asyncRequest"]
}
