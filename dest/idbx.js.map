{
  "version": 3,
  "sources": ["../core/asyncRequest.ts", "../core/cursorHandler.ts", "../ops/add.ts", "../ops/addBulk.ts", "../ops/batch.ts", "../ops/clear.ts", "../ops/count.ts", "../ops/del.ts", "../ops/delBulk.ts", "../ops/get.ts", "../ops/getAll.ts", "../ops/getAllKeys.ts", "../ops/getKey.ts", "../ops/getStore.ts", "../ops/iterate.ts", "../ops/open.ts", "../ops/openDB.ts", "../ops/put.ts", "../ops/putBulk.ts"],
  "sourcesContent": ["export function asyncRequest<T>(\n  req: IDBRequest<T>,\n) {\n  return new Promise<T>((resolve, reject) => {\n    req.addEventListener(\"success\", (ev) => {\n      const target = ev.target as IDBRequest;\n      resolve(target.result);\n    });\n    req.addEventListener(\n      \"error\",\n      (ev) => {\n        const target = ev.target as IDBRequest;\n        reject(new Error(`IndexedDB error: ${target.error?.message}`));\n      },\n    );\n  });\n}\n", "export function cursorHandler(\n  store: IDBObjectStore,\n  onResult: (cursor: IDBCursorWithValue) => boolean | void,\n  onEnd?: () => void,\n): void {\n  const request = store.openCursor();\n  let ended = false;\n  // deno-lint-ignore no-explicit-any\n  request.onsuccess = (event: any) => {\n    const cursor = event.target?.result;\n    if (cursor && !ended) {\n      ended = onResult?.(cursor) ?? false;\n      if (ended) {\n        onEnd?.();\n      }\n    } else if (!ended) {\n      ended = true;\n      onEnd?.();\n    }\n  };\n\n  request.onerror = () => {\n    throw request.error;\n  };\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function add<T>(\n  store: IDBObjectStore,\n  item: T | T[],\n  key?: IDBValidKey,\n): Promise<IDBValidKey> {\n  if (Array.isArray(item)) {\n    return Promise.all(item.map((i) => asyncRequest(store.add(i, key))));\n  }\n  return asyncRequest(store.add(item, key));\n}\n", "import { add } from \"./add.ts\";\n\n/**\n * @deprecated Use `add` instead. `addBulk` will be removed in 2.0.0.\n */\nexport function addBulk<T>(\n  store: IDBObjectStore,\n  items: T[] = [],\n) {\n  return Promise.all(items.map((item) => add(store, item)));\n}\n", "// deno-lint-ignore-file no-explicit-any\n\ninterface IDBXAddCommand<T> {\n  storeName: string;\n  method: \"add\";\n  data: T | T[];\n  key?: IDBValidKey;\n}\n\ninterface IDBXPutCommand<T> {\n  storeName: string;\n  method: \"put\";\n  data: T | T[];\n  key?: IDBValidKey;\n}\n\ninterface IDBXDeleteKeys {\n  keys: IDBValidKey[];\n}\n\ninterface IDBXDeleteKey {\n  key: IDBValidKey | IDBKeyRange;\n}\n\ninterface IDBXDeleteCommandBase {\n  storeName: string;\n  method: \"del\";\n}\n\ntype IDBXDeleteCommand =\n  & IDBXDeleteCommandBase\n  & (\n    | IDBXDeleteKeys\n    | IDBXDeleteKey\n  );\n\ninterface IDBXClearCommand {\n  storeName: string;\n  method: \"clear\";\n}\n\ninterface IDBXGetCommand {\n  storeName: string;\n  method: \"get\";\n  query: IDBValidKey;\n}\n\ninterface IDBXGetAllCommand {\n  storeName: string;\n  method: \"getAll\";\n  query?: IDBValidKey | IDBKeyRange;\n  count?: number;\n}\n\ninterface IDBXGetAllKeysCommand {\n  storeName: string;\n  method: \"getAllKeys\";\n  query: IDBValidKey | IDBKeyRange;\n  count?: number;\n}\n\ninterface IDBXGetKeyCommand {\n  storeName: string;\n  method: \"getKey\";\n  query: IDBValidKey;\n}\n\ninterface IDBXCountCommand {\n  storeName: string;\n  method: \"count\";\n  query: IDBValidKey | IDBKeyRange;\n}\n\ntype IDBXCommand<T> =\n  | IDBXAddCommand<T>\n  | IDBXPutCommand<T>\n  | IDBXDeleteCommand\n  | IDBXClearCommand\n  | IDBXGetCommand\n  | IDBXGetAllCommand\n  | IDBXGetAllKeysCommand\n  | IDBXGetKeyCommand\n  | IDBXCountCommand;\n\nfunction read<T>(\n  emit: IDBRequest<T>,\n  method: keyof IDBXBatchResult<T>,\n  results: IDBXBatchResultItem[],\n) {\n  const index = results.length;\n  results.push([method, undefined as any]);\n  emit.onsuccess = (event) => {\n    const value = (event.target as IDBRequest<T>).result;\n    results[index] = [method, value === undefined ? true : value];\n  };\n  emit.onerror = () => {\n    results[index] = [method, false];\n  };\n}\n\ninterface IDBXBatchResult<T> {\n  add: number;\n  put: number;\n  del: boolean;\n  clear: boolean;\n  get: T;\n  getAll: T[];\n  getAllKeys: IDBValidKey[];\n  getKey: IDBValidKey;\n  count: number;\n}\n\ntype IDBXBatchResultItem<\n  T = any,\n  K extends keyof IDBXBatchResult<T> = keyof IDBXBatchResult<T>,\n> = [\n  K,\n  IDBXBatchResult<T>[K],\n];\n\nexport function batch<T>(\n  db: IDBDatabase,\n  commands: IDBXCommand<T>[],\n  mode: IDBTransactionMode,\n) {\n  const set = new Set(commands.map((c) => c.storeName));\n  const storeNames = Array.from(set);\n\n  const tx = db.transaction(storeNames, mode);\n  const results: IDBXBatchResultItem[] = [];\n  for (const command of commands) {\n    const store = tx.objectStore(command.storeName);\n    switch (command.method) {\n      case \"add\": {\n        const { data, key } = command;\n        if (Array.isArray(data)) {\n          for (const item of data) {\n            read(store.add(item, key), \"add\", results);\n          }\n        } else {\n          read(store.add(data, key), \"add\", results);\n        }\n        break;\n      }\n      case \"put\": {\n        const { data, key } = command;\n        if (Array.isArray(data)) {\n          for (const item of data) {\n            read(store.put(item, key), \"put\", results);\n          }\n        } else {\n          read(store.put(data, key), \"put\", results);\n        }\n        break;\n      }\n      case \"del\": {\n        if (\"keys\" in command) {\n          for (const key of command.keys) {\n            read(store.delete(key), \"del\", results);\n          }\n        } else if (\"key\" in command) {\n          read(store.delete(command.key), \"del\", results);\n        }\n        break;\n      }\n      case \"clear\": {\n        read(store.clear(), \"clear\", results);\n        break;\n      }\n      case \"get\": {\n        const { query } = command;\n        read(store.get(query), \"get\", results);\n        break;\n      }\n      case \"getAll\": {\n        const { query, count } = command;\n        read(store.getAll(query, count), \"getAll\", results);\n        break;\n      }\n      case \"getAllKeys\": {\n        const { query, count } = command;\n        read(store.getAllKeys(query, count), \"getAllKeys\", results);\n        break;\n      }\n      case \"getKey\": {\n        const { query } = command;\n        read(store.getKey(query), \"getKey\", results);\n        break;\n      }\n      case \"count\": {\n        const { query } = command;\n        read(store.count(query), \"count\", results);\n        break;\n      }\n    }\n  }\n  // tx.commit();\n  return {\n    abort: () => tx.abort(),\n    completed: new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve(results);\n      tx.onerror = () => reject(tx.error);\n    }),\n  } as const as {\n    abort: () => void;\n    completed: Promise<IDBXBatchResultItem<T>[]>;\n  };\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function clear(store: IDBObjectStore) {\n  return asyncRequest(store.clear());\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function count(store: IDBObjectStore, query?: IDBValidKey | IDBKeyRange) {\n  return asyncRequest(store.count(query));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function del(\n  store: IDBObjectStore,\n  query: IDBValidKey | IDBKeyRange,\n) {\n  if (Array.isArray(query)) {\n    return Promise.all(query.map((q) => asyncRequest(store.delete(q))));\n  }\n  return asyncRequest(store.delete(query));\n}\n", "import { del } from \"./del.ts\";\n\n/**\n * @deprecated Use `del` instead. `delBulk` will be removed in 2.0.0.\n */\nexport function delBulk(\n  store: IDBObjectStore,\n  keys: Array<IDBValidKey | IDBKeyRange>,\n) {\n  return Promise.all(keys.map((key) => del(store, key)));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function get<T>(store: IDBObjectStore, query: IDBValidKey | IDBKeyRange) {\n  // indexeddb get operation\n  return asyncRequest<T | undefined>(store.get(query));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function getAll<T>(\n  store: IDBObjectStore,\n  query?: IDBValidKey | IDBKeyRange,\n  count?: number,\n) {\n  // indexeddb get operation\n  return asyncRequest<T[]>(store.getAll(query, count));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function getAllKeys(\n  store: IDBObjectStore,\n  query?: IDBValidKey | IDBKeyRange,\n  count?: number,\n) {\n  // indexeddb get operation\n  return asyncRequest<IDBValidKey[]>(store.getAllKeys(query, count));\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function getKey(store: IDBObjectStore, query: IDBValidKey | IDBKeyRange) {\n  // indexeddb get operation\n  return asyncRequest<IDBValidKey | undefined>(store.getKey(query));\n}\n", "export function getStore(\n  db: IDBDatabase,\n  storeName: string,\n  mode: IDBTransactionMode = \"readonly\",\n) {\n  const transaction = db.transaction([storeName], mode);\n  const store = transaction.objectStore(storeName);\n  return store;\n}\n", "import { cursorHandler } from \"../core/cursorHandler.ts\";\n\nexport function iterate<T>(store: IDBObjectStore): AsyncIterable<T> {\n  let _promise: Promise<T>;\n  let _resolve: (value: T) => void;\n  let _reject: (reason?: unknown) => void;\n\n  let next: (() => Promise<T>) | void = () => {\n    _promise = new Promise<T>((resolve, reject) => {\n      _resolve = resolve;\n      _reject = reject;\n    });\n    return _promise;\n  };\n\n  cursorHandler(store, (cursor) => {\n    const value = cursor.value as T;\n    _resolve(value);\n    if (next) {\n      _promise.then(next);\n    }\n    cursor.continue();\n  }, () => (next = undefined));\n  return {\n    async *[Symbol.asyncIterator]() {\n      while (true) {\n        if (next) {\n          try {\n            const result = await next();\n            yield result;\n          } catch (error) {\n            throw error;\n          }\n        } else {\n          break;\n        }\n      }\n    },\n  };\n}\n", "interface IDBXOpenResult {\n  upgrade: (callback: (event: IDBVersionChangeEvent) => void) => void;\n  blocked: (callback: (event: Event) => void) => void;\n  ready: Promise<IDBDatabase>;\n}\n\n/**\n * @deprecated Use `openDB` instead. `open` will be removed in 2.0.0.\n */\nexport function open(name: string, version?: number): IDBXOpenResult {\n  const request = indexedDB.open(name, version);\n\n  return {\n    upgrade: (callback: (event: IDBVersionChangeEvent) => void) => {\n      request.onupgradeneeded = callback;\n    },\n    blocked: (callback: (event: Event) => void) => {\n      request.onblocked = callback;\n    },\n    ready: new Promise<IDBDatabase>((resolve, reject) => {\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    }),\n  };\n}\n", "interface IDBXOpenOptions {\n  version?: number;\n  upgrade?: (db: IDBDatabase, event: IDBVersionChangeEvent) => void;\n  blocked?: (event: Event) => void;\n}\n\nexport function openDB(name: string, options: IDBXOpenOptions = {}) {\n  const request = indexedDB.open(name, options.version);\n\n  request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n    if (options.upgrade) {\n      // deno-lint-ignore no-explicit-any\n      const db = (event.target as any).result;\n      options.upgrade(db, event);\n    }\n  };\n\n  if (options.blocked) {\n    request.onblocked = options.blocked;\n  }\n\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n", "import { asyncRequest } from \"../core/asyncRequest.ts\";\n\nexport function put<T>(store: IDBObjectStore, item: T | T[], key?: IDBValidKey) {\n  if (Array.isArray(item)) {\n    return Promise.all(item.map((i) => asyncRequest(store.put(i, key))));\n  }\n  return asyncRequest(store.put(item, key));\n}\n", "import { put } from \"./put.ts\";\n\n/**\n * @deprecated Use `put` instead. `putBulk` will be removed in 2.0.0.\n */\nexport function putBulk<T>(\n  store: IDBObjectStore,\n  items: T[] = [],\n) {\n  return Promise.all(items.map((item) => put(store, item)));\n}\n"],
  "mappings": "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",
  "names": ["asyncRequest", "req", "resolve", "reject", "ev", "target", "cursorHandler", "store", "onResult", "onEnd", "request", "ended", "event", "cursor", "add", "store", "item", "key", "i", "asyncRequest", "addBulk", "store", "items", "item", "add", "read", "emit", "method", "results", "index", "event", "value", "batch", "db", "commands", "mode", "set", "c", "storeNames", "tx", "command", "store", "data", "key", "item", "query", "count", "resolve", "reject", "clear", "store", "asyncRequest", "count", "store", "query", "asyncRequest", "del", "store", "query", "q", "asyncRequest", "delBulk", "store", "keys", "key", "del", "get", "store", "query", "asyncRequest", "getAll", "store", "query", "count", "asyncRequest", "getAllKeys", "store", "query", "count", "asyncRequest", "getKey", "store", "query", "asyncRequest", "getStore", "db", "storeName", "mode", "iterate", "store", "_promise", "_resolve", "_reject", "next", "resolve", "reject", "cursorHandler", "cursor", "value", "error", "open", "name", "version", "request", "callback", "resolve", "reject", "openDB", "name", "options", "request", "event", "db", "resolve", "reject", "put", "store", "item", "key", "i", "asyncRequest", "putBulk", "store", "items", "item", "put"]
}
